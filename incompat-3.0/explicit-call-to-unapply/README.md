## Explicit Call To `unapply`

In Scala, case classes have an associated extractor method, called `unapply`, that is generated by the compiler in their companion object.
The signature of the `unapplied` method is different between Scala 2 and Scala 3.

The Scala 3 signature is now option-less (see the new [Pattern Matching reference](https://dotty.epfl.ch/docs/reference/changed-features/pattern-matching.html)) which cause incompatibilities when `unapplied` is called explicitly.

Note that this problem does not affect user-defined extractors, whose signature stays the same across Scala versions.

Given the following case class definition:

``` scala
case class Location(lat: Double, long: Double)
```

The Scala 2 compiler produces the following `unapply` method.

``` scala
object Location {
  def unapply(location: Location): Option[(Double, Double)] = Some((location.lat, location.long))
}
```

Whereas the Scala 3 compiler produces the following `unapply` method.

``` scala
object User {
  def unapply(location: Location): Location = location
}
```

Consequently the following code does not compile anymore.

``` scala
def tuple(location: Location): (Int, Int) = {
  Location.unapply(location).get
}
```

A possible solution to make it compile is to use pattern binding:

``` scala
def tuple(location: Location): (Int, Int) = {
  val Location(lat, lon) = location
  (lat, lon)
}
```
